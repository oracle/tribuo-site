<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc (24) -->
<title>Source code</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="source: package: org.tribuo.classification.explanations.lime, class: LIMEColumnar">
<meta name="generator" content="javadoc/SourceToHTMLConverter">
<link rel="stylesheet" type="text/css" href="../../../../../../resource-files/stylesheet.css" title="Style">
</head>
<body class="source-page">
<main role="main">
<div class="source-container">
<pre><span class="source-line-no">001</span><span id="line-1">/*</span>
<span class="source-line-no">002</span><span id="line-2"> * Copyright (c) 2015-2020, Oracle and/or its affiliates. All rights reserved.</span>
<span class="source-line-no">003</span><span id="line-3"> *</span>
<span class="source-line-no">004</span><span id="line-4"> * Licensed under the Apache License, Version 2.0 (the "License");</span>
<span class="source-line-no">005</span><span id="line-5"> * you may not use this file except in compliance with the License.</span>
<span class="source-line-no">006</span><span id="line-6"> * You may obtain a copy of the License at</span>
<span class="source-line-no">007</span><span id="line-7"> *</span>
<span class="source-line-no">008</span><span id="line-8"> *     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="source-line-no">009</span><span id="line-9"> *</span>
<span class="source-line-no">010</span><span id="line-10"> * Unless required by applicable law or agreed to in writing, software</span>
<span class="source-line-no">011</span><span id="line-11"> * distributed under the License is distributed on an "AS IS" BASIS,</span>
<span class="source-line-no">012</span><span id="line-12"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express implied.</span>
<span class="source-line-no">013</span><span id="line-13"> * See the License for the specific language governing permissions and</span>
<span class="source-line-no">014</span><span id="line-14"> * limitations under the License.</span>
<span class="source-line-no">015</span><span id="line-15"> */</span>
<span class="source-line-no">016</span><span id="line-16"></span>
<span class="source-line-no">017</span><span id="line-17">package org.tribuo.classification.explanations.lime;</span>
<span class="source-line-no">018</span><span id="line-18"></span>
<span class="source-line-no">019</span><span id="line-19">import com.oracle.labs.mlrg.olcut.util.Pair;</span>
<span class="source-line-no">020</span><span id="line-20">import org.tribuo.CategoricalInfo;</span>
<span class="source-line-no">021</span><span id="line-21">import org.tribuo.Example;</span>
<span class="source-line-no">022</span><span id="line-22">import org.tribuo.Feature;</span>
<span class="source-line-no">023</span><span id="line-23">import org.tribuo.ImmutableFeatureMap;</span>
<span class="source-line-no">024</span><span id="line-24">import org.tribuo.Model;</span>
<span class="source-line-no">025</span><span id="line-25">import org.tribuo.Prediction;</span>
<span class="source-line-no">026</span><span id="line-26">import org.tribuo.RealInfo;</span>
<span class="source-line-no">027</span><span id="line-27">import org.tribuo.SparseModel;</span>
<span class="source-line-no">028</span><span id="line-28">import org.tribuo.SparseTrainer;</span>
<span class="source-line-no">029</span><span id="line-29">import org.tribuo.VariableIDInfo;</span>
<span class="source-line-no">030</span><span id="line-30">import org.tribuo.VariableInfo;</span>
<span class="source-line-no">031</span><span id="line-31">import org.tribuo.classification.Label;</span>
<span class="source-line-no">032</span><span id="line-32">import org.tribuo.classification.LabelFactory;</span>
<span class="source-line-no">033</span><span id="line-33">import org.tribuo.classification.explanations.ColumnarExplainer;</span>
<span class="source-line-no">034</span><span id="line-34">import org.tribuo.data.columnar.ColumnarFeature;</span>
<span class="source-line-no">035</span><span id="line-35">import org.tribuo.data.columnar.FieldProcessor;</span>
<span class="source-line-no">036</span><span id="line-36">import org.tribuo.data.columnar.ResponseProcessor;</span>
<span class="source-line-no">037</span><span id="line-37">import org.tribuo.data.columnar.RowProcessor;</span>
<span class="source-line-no">038</span><span id="line-38">import org.tribuo.impl.ArrayExample;</span>
<span class="source-line-no">039</span><span id="line-39">import org.tribuo.impl.ListExample;</span>
<span class="source-line-no">040</span><span id="line-40">import org.tribuo.math.la.SparseVector;</span>
<span class="source-line-no">041</span><span id="line-41">import org.tribuo.provenance.SimpleDataSourceProvenance;</span>
<span class="source-line-no">042</span><span id="line-42">import org.tribuo.regression.Regressor;</span>
<span class="source-line-no">043</span><span id="line-43">import org.tribuo.regression.evaluation.RegressionEvaluation;</span>
<span class="source-line-no">044</span><span id="line-44">import org.tribuo.util.Util;</span>
<span class="source-line-no">045</span><span id="line-45">import org.tribuo.util.tokens.Token;</span>
<span class="source-line-no">046</span><span id="line-46">import org.tribuo.util.tokens.Tokenizer;</span>
<span class="source-line-no">047</span><span id="line-47"></span>
<span class="source-line-no">048</span><span id="line-48">import java.util.ArrayList;</span>
<span class="source-line-no">049</span><span id="line-49">import java.util.Arrays;</span>
<span class="source-line-no">050</span><span id="line-50">import java.util.HashMap;</span>
<span class="source-line-no">051</span><span id="line-51">import java.util.List;</span>
<span class="source-line-no">052</span><span id="line-52">import java.util.ListIterator;</span>
<span class="source-line-no">053</span><span id="line-53">import java.util.Map;</span>
<span class="source-line-no">054</span><span id="line-54">import java.util.Optional;</span>
<span class="source-line-no">055</span><span id="line-55">import java.util.Random;</span>
<span class="source-line-no">056</span><span id="line-56">import java.util.SplittableRandom;</span>
<span class="source-line-no">057</span><span id="line-57"></span>
<span class="source-line-no">058</span><span id="line-58">/**</span>
<span class="source-line-no">059</span><span id="line-59"> * Uses the columnar data processing infrastructure to mix text and tabular data.</span>
<span class="source-line-no">060</span><span id="line-60"> * &lt;p&gt;</span>
<span class="source-line-no">061</span><span id="line-61"> * If the supplied {@link RowProcessor} doesn't reference any text or binarised fields</span>
<span class="source-line-no">062</span><span id="line-62"> * then it delegates to {@link LIMEBase#explain}, though it's still more expensive at</span>
<span class="source-line-no">063</span><span id="line-63"> * construction time.</span>
<span class="source-line-no">064</span><span id="line-64"> * &lt;p&gt;</span>
<span class="source-line-no">065</span><span id="line-65"> * See:</span>
<span class="source-line-no">066</span><span id="line-66"> * &lt;pre&gt;</span>
<span class="source-line-no">067</span><span id="line-67"> * Ribeiro MT, Singh S, Guestrin C.</span>
<span class="source-line-no">068</span><span id="line-68"> * "Why should I trust you?: Explaining the predictions of any classifier"</span>
<span class="source-line-no">069</span><span id="line-69"> * Proceedings of the 22nd ACM SIGKDD International Conference on Knowledge Discovery and Data Mining 2016.</span>
<span class="source-line-no">070</span><span id="line-70"> * &lt;/pre&gt;</span>
<span class="source-line-no">071</span><span id="line-71"> */</span>
<span class="source-line-no">072</span><span id="line-72">public class LIMEColumnar extends LIMEBase implements ColumnarExplainer&lt;Regressor&gt; {</span>
<span class="source-line-no">073</span><span id="line-73"></span>
<span class="source-line-no">074</span><span id="line-74">    private final RowProcessor&lt;Label&gt; generator;</span>
<span class="source-line-no">075</span><span id="line-75"></span>
<span class="source-line-no">076</span><span id="line-76">    private final Map&lt;String,FieldProcessor&gt; binarisedFields = new HashMap&lt;&gt;();</span>
<span class="source-line-no">077</span><span id="line-77"></span>
<span class="source-line-no">078</span><span id="line-78">    private final Map&lt;String,FieldProcessor&gt; tabularFields = new HashMap&lt;&gt;();</span>
<span class="source-line-no">079</span><span id="line-79"></span>
<span class="source-line-no">080</span><span id="line-80">    private final Map&lt;String,FieldProcessor&gt; textFields = new HashMap&lt;&gt;();</span>
<span class="source-line-no">081</span><span id="line-81"></span>
<span class="source-line-no">082</span><span id="line-82">    private final ResponseProcessor&lt;Label&gt; responseProcessor;</span>
<span class="source-line-no">083</span><span id="line-83"></span>
<span class="source-line-no">084</span><span id="line-84">    private final Map&lt;String,List&lt;VariableInfo&gt;&gt; binarisedInfos;</span>
<span class="source-line-no">085</span><span id="line-85"></span>
<span class="source-line-no">086</span><span id="line-86">    private final Map&lt;String,double[]&gt; binarisedCDFs;</span>
<span class="source-line-no">087</span><span id="line-87"></span>
<span class="source-line-no">088</span><span id="line-88">    private final ImmutableFeatureMap binarisedDomain;</span>
<span class="source-line-no">089</span><span id="line-89"></span>
<span class="source-line-no">090</span><span id="line-90">    private final ImmutableFeatureMap tabularDomain;</span>
<span class="source-line-no">091</span><span id="line-91"></span>
<span class="source-line-no">092</span><span id="line-92">    private final ImmutableFeatureMap textDomain;</span>
<span class="source-line-no">093</span><span id="line-93"></span>
<span class="source-line-no">094</span><span id="line-94">    private final Tokenizer tokenizer;</span>
<span class="source-line-no">095</span><span id="line-95"></span>
<span class="source-line-no">096</span><span id="line-96">    private final ThreadLocal&lt;Tokenizer&gt; tokenizerThreadLocal;</span>
<span class="source-line-no">097</span><span id="line-97"></span>
<span class="source-line-no">098</span><span id="line-98">    /**</span>
<span class="source-line-no">099</span><span id="line-99">     * Constructs a LIME explainer for a model which uses the columnar data processing system.</span>
<span class="source-line-no">100</span><span id="line-100">     * @param rng The rng to use for sampling.</span>
<span class="source-line-no">101</span><span id="line-101">     * @param innerModel The model to explain.</span>
<span class="source-line-no">102</span><span id="line-102">     * @param explanationTrainer The trainer for the sparse model used to explain.</span>
<span class="source-line-no">103</span><span id="line-103">     * @param numSamples The number of samples to generate in each explanation.</span>
<span class="source-line-no">104</span><span id="line-104">     * @param exampleGenerator The {@link RowProcessor} which converts columnar data into an {@link Example}.</span>
<span class="source-line-no">105</span><span id="line-105">     * @param tokenizer The tokenizer to use on any text fields.</span>
<span class="source-line-no">106</span><span id="line-106">     */</span>
<span class="source-line-no">107</span><span id="line-107">    public LIMEColumnar(SplittableRandom rng, Model&lt;Label&gt; innerModel, SparseTrainer&lt;Regressor&gt; explanationTrainer,</span>
<span class="source-line-no">108</span><span id="line-108">                        int numSamples, RowProcessor&lt;Label&gt; exampleGenerator, Tokenizer tokenizer) {</span>
<span class="source-line-no">109</span><span id="line-109">        super(rng, innerModel, explanationTrainer, numSamples);</span>
<span class="source-line-no">110</span><span id="line-110">        this.generator = exampleGenerator.copy();</span>
<span class="source-line-no">111</span><span id="line-111">        this.responseProcessor = generator.getResponseProcessor();</span>
<span class="source-line-no">112</span><span id="line-112">        this.tokenizer = tokenizer;</span>
<span class="source-line-no">113</span><span id="line-113">        this.tokenizerThreadLocal = ThreadLocal.withInitial(() -&gt; {try { return this.tokenizer.clone(); } catch (CloneNotSupportedException e) { throw new IllegalArgumentException("Tokenizer not cloneable",e); }});</span>
<span class="source-line-no">114</span><span id="line-114">        if (!this.generator.isConfigured()) {</span>
<span class="source-line-no">115</span><span id="line-115">            this.generator.expandRegexMapping(innerModel);</span>
<span class="source-line-no">116</span><span id="line-116">        }</span>
<span class="source-line-no">117</span><span id="line-117">        this.binarisedInfos = new HashMap&lt;&gt;();</span>
<span class="source-line-no">118</span><span id="line-118">        ArrayList&lt;VariableInfo&gt; infos = new ArrayList&lt;&gt;();</span>
<span class="source-line-no">119</span><span id="line-119">        for (VariableInfo i : innerModel.getFeatureIDMap()) {</span>
<span class="source-line-no">120</span><span id="line-120">            infos.add(i);</span>
<span class="source-line-no">121</span><span id="line-121">        }</span>
<span class="source-line-no">122</span><span id="line-122">        ArrayList&lt;VariableInfo&gt; allBinarisedInfos = new ArrayList&lt;&gt;();</span>
<span class="source-line-no">123</span><span id="line-123">        ArrayList&lt;VariableInfo&gt; tabularInfos = new ArrayList&lt;&gt;();</span>
<span class="source-line-no">124</span><span id="line-124">        ArrayList&lt;VariableInfo&gt; textInfos = new ArrayList&lt;&gt;();</span>
<span class="source-line-no">125</span><span id="line-125">        for (Map.Entry&lt;String,FieldProcessor&gt; p : generator.getFieldProcessors().entrySet()) {</span>
<span class="source-line-no">126</span><span id="line-126">            String searchName = p.getKey() + ColumnarFeature.JOINER;</span>
<span class="source-line-no">127</span><span id="line-127">            switch (p.getValue().getFeatureType()) {</span>
<span class="source-line-no">128</span><span id="line-128">                case BINARISED_CATEGORICAL: {</span>
<span class="source-line-no">129</span><span id="line-129">                    int numNamespaces = p.getValue().getNumNamespaces();</span>
<span class="source-line-no">130</span><span id="line-130">                    if (numNamespaces &gt; 1) {</span>
<span class="source-line-no">131</span><span id="line-131">                        for (int i = 0; i &lt; numNamespaces; i++) {</span>
<span class="source-line-no">132</span><span id="line-132">                            String namespace = p.getKey() + FieldProcessor.NAMESPACE + i;</span>
<span class="source-line-no">133</span><span id="line-133">                            String namespaceSearchName = namespace + ColumnarFeature.JOINER;</span>
<span class="source-line-no">134</span><span id="line-134">                            binarisedFields.put(namespace, p.getValue());</span>
<span class="source-line-no">135</span><span id="line-135">                            List&lt;VariableInfo&gt; binarisedInfoList = this.binarisedInfos.computeIfAbsent(namespace, (k) -&gt; new ArrayList&lt;&gt;());</span>
<span class="source-line-no">136</span><span id="line-136">                            ListIterator&lt;VariableInfo&gt; li = infos.listIterator();</span>
<span class="source-line-no">137</span><span id="line-137">                            while (li.hasNext()) {</span>
<span class="source-line-no">138</span><span id="line-138">                                VariableInfo info = li.next();</span>
<span class="source-line-no">139</span><span id="line-139">                                if (info.getName().startsWith(namespaceSearchName)) {</span>
<span class="source-line-no">140</span><span id="line-140">                                    if (((CategoricalInfo) info).getUniqueObservations() != 1) {</span>
<span class="source-line-no">141</span><span id="line-141">                                        throw new IllegalStateException("Processor " + p.getKey() + ", should have been binary, but had " + ((CategoricalInfo) info).getUniqueObservations() + " unique values");</span>
<span class="source-line-no">142</span><span id="line-142">                                    }</span>
<span class="source-line-no">143</span><span id="line-143">                                    binarisedInfoList.add(info);</span>
<span class="source-line-no">144</span><span id="line-144">                                    allBinarisedInfos.add(info);</span>
<span class="source-line-no">145</span><span id="line-145">                                    li.remove();</span>
<span class="source-line-no">146</span><span id="line-146">                                }</span>
<span class="source-line-no">147</span><span id="line-147">                            }</span>
<span class="source-line-no">148</span><span id="line-148">                        }</span>
<span class="source-line-no">149</span><span id="line-149">                    } else {</span>
<span class="source-line-no">150</span><span id="line-150">                        binarisedFields.put(p.getKey(), p.getValue());</span>
<span class="source-line-no">151</span><span id="line-151">                        List&lt;VariableInfo&gt; binarisedInfoList = this.binarisedInfos.computeIfAbsent(p.getKey(), (k) -&gt; new ArrayList&lt;&gt;());</span>
<span class="source-line-no">152</span><span id="line-152">                        ListIterator&lt;VariableInfo&gt; li = infos.listIterator();</span>
<span class="source-line-no">153</span><span id="line-153">                        while (li.hasNext()) {</span>
<span class="source-line-no">154</span><span id="line-154">                            VariableInfo i = li.next();</span>
<span class="source-line-no">155</span><span id="line-155">                            if (i.getName().startsWith(searchName)) {</span>
<span class="source-line-no">156</span><span id="line-156">                                if (((CategoricalInfo) i).getUniqueObservations() != 1) {</span>
<span class="source-line-no">157</span><span id="line-157">                                    throw new IllegalStateException("Processor " + p.getKey() + ", should have been binary, but had " + ((CategoricalInfo) i).getUniqueObservations() + " unique values");</span>
<span class="source-line-no">158</span><span id="line-158">                                }</span>
<span class="source-line-no">159</span><span id="line-159">                                binarisedInfoList.add(i);</span>
<span class="source-line-no">160</span><span id="line-160">                                allBinarisedInfos.add(i);</span>
<span class="source-line-no">161</span><span id="line-161">                                li.remove();</span>
<span class="source-line-no">162</span><span id="line-162">                            }</span>
<span class="source-line-no">163</span><span id="line-163">                        }</span>
<span class="source-line-no">164</span><span id="line-164">                    }</span>
<span class="source-line-no">165</span><span id="line-165">                    break;</span>
<span class="source-line-no">166</span><span id="line-166">                }</span>
<span class="source-line-no">167</span><span id="line-167">                case CATEGORICAL:</span>
<span class="source-line-no">168</span><span id="line-168">                case REAL: {</span>
<span class="source-line-no">169</span><span id="line-169">                    tabularFields.put(p.getKey(), p.getValue());</span>
<span class="source-line-no">170</span><span id="line-170">                    ListIterator&lt;VariableInfo&gt; li = infos.listIterator();</span>
<span class="source-line-no">171</span><span id="line-171">                    while (li.hasNext()) {</span>
<span class="source-line-no">172</span><span id="line-172">                        VariableInfo i = li.next();</span>
<span class="source-line-no">173</span><span id="line-173">                        if (i.getName().startsWith(searchName)) {</span>
<span class="source-line-no">174</span><span id="line-174">                            tabularInfos.add(i);</span>
<span class="source-line-no">175</span><span id="line-175">                            li.remove();</span>
<span class="source-line-no">176</span><span id="line-176">                        }</span>
<span class="source-line-no">177</span><span id="line-177">                    }</span>
<span class="source-line-no">178</span><span id="line-178">                    break;</span>
<span class="source-line-no">179</span><span id="line-179">                }</span>
<span class="source-line-no">180</span><span id="line-180">                case TEXT: {</span>
<span class="source-line-no">181</span><span id="line-181">                    textFields.put(p.getKey(), p.getValue());</span>
<span class="source-line-no">182</span><span id="line-182">                    ListIterator&lt;VariableInfo&gt; li = infos.listIterator();</span>
<span class="source-line-no">183</span><span id="line-183">                    while (li.hasNext()) {</span>
<span class="source-line-no">184</span><span id="line-184">                        VariableInfo i = li.next();</span>
<span class="source-line-no">185</span><span id="line-185">                        if (i.getName().startsWith(searchName)) {</span>
<span class="source-line-no">186</span><span id="line-186">                            textInfos.add(i);</span>
<span class="source-line-no">187</span><span id="line-187">                            li.remove();</span>
<span class="source-line-no">188</span><span id="line-188">                        }</span>
<span class="source-line-no">189</span><span id="line-189">                    }</span>
<span class="source-line-no">190</span><span id="line-190">                    break;</span>
<span class="source-line-no">191</span><span id="line-191">                }</span>
<span class="source-line-no">192</span><span id="line-192">                default:</span>
<span class="source-line-no">193</span><span id="line-193">                    throw new IllegalArgumentException("Unsupported feature type " + p.getValue().getFeatureType());</span>
<span class="source-line-no">194</span><span id="line-194">            }</span>
<span class="source-line-no">195</span><span id="line-195">        }</span>
<span class="source-line-no">196</span><span id="line-196">        if (infos.size() != 0) {</span>
<span class="source-line-no">197</span><span id="line-197">            throw new IllegalArgumentException("Found " + infos.size() + " unsupported features.");</span>
<span class="source-line-no">198</span><span id="line-198">        }</span>
<span class="source-line-no">199</span><span id="line-199">        if (generator.getFeatureProcessors().size() != 0) {</span>
<span class="source-line-no">200</span><span id="line-200">            throw new IllegalArgumentException("LIMEColumnar does not support FeatureProcessors.");</span>
<span class="source-line-no">201</span><span id="line-201">        }</span>
<span class="source-line-no">202</span><span id="line-202">        this.tabularDomain = new ImmutableFeatureMap(tabularInfos);</span>
<span class="source-line-no">203</span><span id="line-203">        this.textDomain = new ImmutableFeatureMap(textInfos);</span>
<span class="source-line-no">204</span><span id="line-204">        this.binarisedDomain = new ImmutableFeatureMap(allBinarisedInfos);</span>
<span class="source-line-no">205</span><span id="line-205">        this.binarisedCDFs = new HashMap&lt;&gt;();</span>
<span class="source-line-no">206</span><span id="line-206">        for (Map.Entry&lt;String,List&lt;VariableInfo&gt;&gt; e : binarisedInfos.entrySet()) {</span>
<span class="source-line-no">207</span><span id="line-207">            long totalCount = 0;</span>
<span class="source-line-no">208</span><span id="line-208">            long[] counts = new long[e.getValue().size()+1];</span>
<span class="source-line-no">209</span><span id="line-209">            int i = 0;</span>
<span class="source-line-no">210</span><span id="line-210">            for (VariableInfo info : e.getValue()) {</span>
<span class="source-line-no">211</span><span id="line-211">                long curCount = info.getCount();</span>
<span class="source-line-no">212</span><span id="line-212">                counts[i] = curCount;</span>
<span class="source-line-no">213</span><span id="line-213">                totalCount += curCount;</span>
<span class="source-line-no">214</span><span id="line-214">                i++;</span>
<span class="source-line-no">215</span><span id="line-215">            }</span>
<span class="source-line-no">216</span><span id="line-216">            long zeroCount = numTrainingExamples - totalCount;</span>
<span class="source-line-no">217</span><span id="line-217">            if (zeroCount &lt; 0) {</span>
<span class="source-line-no">218</span><span id="line-218">                throw new IllegalStateException("Processor " + e.getKey() + " purports to be a BINARISED_CATEGORICAL, but had overlap in it's elements");</span>
<span class="source-line-no">219</span><span id="line-219">            }</span>
<span class="source-line-no">220</span><span id="line-220">            counts[i] = zeroCount;</span>
<span class="source-line-no">221</span><span id="line-221">            double[] cdf = Util.generateCDF(counts,numTrainingExamples);</span>
<span class="source-line-no">222</span><span id="line-222">            binarisedCDFs.put(e.getKey(),cdf);</span>
<span class="source-line-no">223</span><span id="line-223">        }</span>
<span class="source-line-no">224</span><span id="line-224">    }</span>
<span class="source-line-no">225</span><span id="line-225"></span>
<span class="source-line-no">226</span><span id="line-226">    @Override</span>
<span class="source-line-no">227</span><span id="line-227">    public LIMEExplanation explain(Map&lt;String, String&gt; input) {</span>
<span class="source-line-no">228</span><span id="line-228">        return explainWithSamples(input).getA();</span>
<span class="source-line-no">229</span><span id="line-229">    }</span>
<span class="source-line-no">230</span><span id="line-230"></span>
<span class="source-line-no">231</span><span id="line-231">    protected Pair&lt;LIMEExplanation, List&lt;Example&lt;Regressor&gt;&gt;&gt; explainWithSamples(Map&lt;String, String&gt; input) {</span>
<span class="source-line-no">232</span><span id="line-232">        Optional&lt;Example&lt;Label&gt;&gt; optExample = generator.generateExample(input,false);</span>
<span class="source-line-no">233</span><span id="line-233">        if (optExample.isPresent()) {</span>
<span class="source-line-no">234</span><span id="line-234">            Example&lt;Label&gt; example = optExample.get();</span>
<span class="source-line-no">235</span><span id="line-235">            if ((textDomain.size() == 0) &amp;&amp; (binarisedCDFs.size() == 0)) {</span>
<span class="source-line-no">236</span><span id="line-236">                // Short circuit if there are no text or binarised fields.</span>
<span class="source-line-no">237</span><span id="line-237">                return explainWithSamples(example);</span>
<span class="source-line-no">238</span><span id="line-238">            } else {</span>
<span class="source-line-no">239</span><span id="line-239">                Prediction&lt;Label&gt; prediction = innerModel.predict(example);</span>
<span class="source-line-no">240</span><span id="line-240"></span>
<span class="source-line-no">241</span><span id="line-241">                // Build the input example with simplified text features</span>
<span class="source-line-no">242</span><span id="line-242">                ArrayExample&lt;Regressor&gt; labelledExample = new ArrayExample&lt;&gt;(transformOutput(prediction));</span>
<span class="source-line-no">243</span><span id="line-243"></span>
<span class="source-line-no">244</span><span id="line-244">                // Add the tabular features</span>
<span class="source-line-no">245</span><span id="line-245">                for (Feature f : example) {</span>
<span class="source-line-no">246</span><span id="line-246">                    if (tabularDomain.getID(f.getName()) != -1) {</span>
<span class="source-line-no">247</span><span id="line-247">                        labelledExample.add(f);</span>
<span class="source-line-no">248</span><span id="line-248">                    }</span>
<span class="source-line-no">249</span><span id="line-249">                }</span>
<span class="source-line-no">250</span><span id="line-250">                // Extract the tabular features into a SparseVector for later</span>
<span class="source-line-no">251</span><span id="line-251">                SparseVector tabularVector = SparseVector.createSparseVector(labelledExample,tabularDomain,false);</span>
<span class="source-line-no">252</span><span id="line-252"></span>
<span class="source-line-no">253</span><span id="line-253">                // Tokenize the text fields, and generate the perturbed text representation</span>
<span class="source-line-no">254</span><span id="line-254">                Map&lt;String, String&gt; exampleTextValues = new HashMap&lt;&gt;();</span>
<span class="source-line-no">255</span><span id="line-255">                Map&lt;String, List&lt;Token&gt;&gt; exampleTextTokens = new HashMap&lt;&gt;();</span>
<span class="source-line-no">256</span><span id="line-256">                for (Map.Entry&lt;String,FieldProcessor&gt; e : textFields.entrySet()) {</span>
<span class="source-line-no">257</span><span id="line-257">                    String value = input.get(e.getKey());</span>
<span class="source-line-no">258</span><span id="line-258">                    if (value != null) {</span>
<span class="source-line-no">259</span><span id="line-259">                        List&lt;Token&gt; tokens = tokenizerThreadLocal.get().tokenize(value);</span>
<span class="source-line-no">260</span><span id="line-260">                        for (int i = 0; i &lt; tokens.size(); i++) {</span>
<span class="source-line-no">261</span><span id="line-261">                            labelledExample.add(nameFeature(e.getKey(),tokens.get(i).text,i),1.0);</span>
<span class="source-line-no">262</span><span id="line-262">                        }</span>
<span class="source-line-no">263</span><span id="line-263">                        exampleTextValues.put(e.getKey(),value);</span>
<span class="source-line-no">264</span><span id="line-264">                        exampleTextTokens.put(e.getKey(),tokens);</span>
<span class="source-line-no">265</span><span id="line-265">                    }</span>
<span class="source-line-no">266</span><span id="line-266">                }</span>
<span class="source-line-no">267</span><span id="line-267"></span>
<span class="source-line-no">268</span><span id="line-268">                // Sample a dataset.</span>
<span class="source-line-no">269</span><span id="line-269">                List&lt;Example&lt;Regressor&gt;&gt; sample = sampleData(tabularVector,exampleTextValues,exampleTextTokens);</span>
<span class="source-line-no">270</span><span id="line-270"></span>
<span class="source-line-no">271</span><span id="line-271">                // Generate a sparse model on the sampled data.</span>
<span class="source-line-no">272</span><span id="line-272">                SparseModel&lt;Regressor&gt; model = trainExplainer(labelledExample, sample);</span>
<span class="source-line-no">273</span><span id="line-273"></span>
<span class="source-line-no">274</span><span id="line-274">                // Test the sparse model against the predictions of the real model.</span>
<span class="source-line-no">275</span><span id="line-275">                List&lt;Prediction&lt;Regressor&gt;&gt; predictions = new ArrayList&lt;&gt;(model.predict(sample));</span>
<span class="source-line-no">276</span><span id="line-276">                predictions.add(model.predict(labelledExample));</span>
<span class="source-line-no">277</span><span id="line-277">                RegressionEvaluation evaluation = evaluator.evaluate(model,predictions,new SimpleDataSourceProvenance("LIMEColumnar sampled data",regressionFactory));</span>
<span class="source-line-no">278</span><span id="line-278"></span>
<span class="source-line-no">279</span><span id="line-279">                return new Pair&lt;&gt;(new LIMEExplanation(model, prediction, evaluation),sample);</span>
<span class="source-line-no">280</span><span id="line-280">            }</span>
<span class="source-line-no">281</span><span id="line-281">        } else {</span>
<span class="source-line-no">282</span><span id="line-282">            throw new IllegalArgumentException("Label not found in input " + input.toString());</span>
<span class="source-line-no">283</span><span id="line-283">        }</span>
<span class="source-line-no">284</span><span id="line-284">    }</span>
<span class="source-line-no">285</span><span id="line-285"></span>
<span class="source-line-no">286</span><span id="line-286">    /**</span>
<span class="source-line-no">287</span><span id="line-287">     * Generate the feature name by combining the word and index.</span>
<span class="source-line-no">288</span><span id="line-288">     * @param fieldName The name of the column this text feature came from.</span>
<span class="source-line-no">289</span><span id="line-289">     * @param name The word.</span>
<span class="source-line-no">290</span><span id="line-290">     * @param idx The index.</span>
<span class="source-line-no">291</span><span id="line-291">     * @return A string representing both of the inputs.</span>
<span class="source-line-no">292</span><span id="line-292">     */</span>
<span class="source-line-no">293</span><span id="line-293">    protected String nameFeature(String fieldName, String name, int idx) {</span>
<span class="source-line-no">294</span><span id="line-294">        return fieldName + "@" + name+"@idx"+idx;</span>
<span class="source-line-no">295</span><span id="line-295">    }</span>
<span class="source-line-no">296</span><span id="line-296"></span>
<span class="source-line-no">297</span><span id="line-297">    /**</span>
<span class="source-line-no">298</span><span id="line-298">     * Samples a dataset based on the provided text, tokens and tabular features.</span>
<span class="source-line-no">299</span><span id="line-299">     *</span>
<span class="source-line-no">300</span><span id="line-300">     * The text features are sampled using the {@link LIMEText} sampling approach,</span>
<span class="source-line-no">301</span><span id="line-301">     * and the tabular features are sampled using the {@link LIMEBase} approach.</span>
<span class="source-line-no">302</span><span id="line-302">     *</span>
<span class="source-line-no">303</span><span id="line-303">     * The weight for each example is based on the distance for the tabular features,</span>
<span class="source-line-no">304</span><span id="line-304">     * combined with the distance for the text features (which is a hamming distance).</span>
<span class="source-line-no">305</span><span id="line-305">     * These distances are averaged using a weight function representing how many tokens</span>
<span class="source-line-no">306</span><span id="line-306">     * there are in the text fields, and how many tabular features there are.</span>
<span class="source-line-no">307</span><span id="line-307">     *</span>
<span class="source-line-no">308</span><span id="line-308">     * This weight calculation is subject to change, as it's not necessarily optimal.</span>
<span class="source-line-no">309</span><span id="line-309">     * @param tabularVector The tabular (i.e., non-text) features.</span>
<span class="source-line-no">310</span><span id="line-310">     * @param text A map from the field names to the field values for the text fields.</span>
<span class="source-line-no">311</span><span id="line-311">     * @param textTokens A map from the field names to lists of tokens for those fields.</span>
<span class="source-line-no">312</span><span id="line-312">     * @return A sampled dataset.</span>
<span class="source-line-no">313</span><span id="line-313">     */</span>
<span class="source-line-no">314</span><span id="line-314">    private List&lt;Example&lt;Regressor&gt;&gt; sampleData(SparseVector tabularVector, Map&lt;String,String&gt; text, Map&lt;String,List&lt;Token&gt;&gt; textTokens) {</span>
<span class="source-line-no">315</span><span id="line-315">        List&lt;Example&lt;Regressor&gt;&gt; output = new ArrayList&lt;&gt;();</span>
<span class="source-line-no">316</span><span id="line-316"></span>
<span class="source-line-no">317</span><span id="line-317">        Random innerRNG = new Random(rng.nextLong());</span>
<span class="source-line-no">318</span><span id="line-318">        for (int i = 0; i &lt; numSamples; i++) {</span>
<span class="source-line-no">319</span><span id="line-319">            // Create the full example</span>
<span class="source-line-no">320</span><span id="line-320">            ListExample&lt;Label&gt; sampledExample = new ListExample&lt;&gt;(LabelFactory.UNKNOWN_LABEL);</span>
<span class="source-line-no">321</span><span id="line-321"></span>
<span class="source-line-no">322</span><span id="line-322">            // Tabular features.</span>
<span class="source-line-no">323</span><span id="line-323">            List&lt;Feature&gt; tabularFeatures = new ArrayList&lt;&gt;();</span>
<span class="source-line-no">324</span><span id="line-324">            // Sample the categorical and real features</span>
<span class="source-line-no">325</span><span id="line-325">            for (VariableInfo info : tabularDomain) {</span>
<span class="source-line-no">326</span><span id="line-326">                int id = ((VariableIDInfo) info).getID();</span>
<span class="source-line-no">327</span><span id="line-327">                double inputValue = tabularVector.get(id);</span>
<span class="source-line-no">328</span><span id="line-328"></span>
<span class="source-line-no">329</span><span id="line-329">                if (info instanceof CategoricalInfo) {</span>
<span class="source-line-no">330</span><span id="line-330">                    // This one is tricksy as categorical info essentially implicitly includes a zero.</span>
<span class="source-line-no">331</span><span id="line-331">                    CategoricalInfo catInfo = (CategoricalInfo) info;</span>
<span class="source-line-no">332</span><span id="line-332">                    double sample = catInfo.frequencyBasedSample(innerRNG,numTrainingExamples);</span>
<span class="source-line-no">333</span><span id="line-333">                    // If we didn't sample zero.</span>
<span class="source-line-no">334</span><span id="line-334">                    if (Math.abs(sample) &gt; 1e-10) {</span>
<span class="source-line-no">335</span><span id="line-335">                        Feature newFeature = new Feature(info.getName(),sample);</span>
<span class="source-line-no">336</span><span id="line-336">                        tabularFeatures.add(newFeature);</span>
<span class="source-line-no">337</span><span id="line-337">                    }</span>
<span class="source-line-no">338</span><span id="line-338">                } else if (info instanceof RealInfo) {</span>
<span class="source-line-no">339</span><span id="line-339">                    RealInfo realInfo = (RealInfo) info;</span>
<span class="source-line-no">340</span><span id="line-340">                    // As realInfo is sparse we sample from the mixture distribution,</span>
<span class="source-line-no">341</span><span id="line-341">                    // either 0 or N(inputValue,variance).</span>
<span class="source-line-no">342</span><span id="line-342">                    // This assumes realInfo never observed a zero, which is enforced from v2.1</span>
<span class="source-line-no">343</span><span id="line-343">                    // TODO check this makes sense. If the input value is zero do we still want to sample spike and slab?</span>
<span class="source-line-no">344</span><span id="line-344">                    // If it's not zero do we want to?</span>
<span class="source-line-no">345</span><span id="line-345">                    int count = realInfo.getCount();</span>
<span class="source-line-no">346</span><span id="line-346">                    double threshold = count / ((double)numTrainingExamples);</span>
<span class="source-line-no">347</span><span id="line-347">                    if (innerRNG.nextDouble() &lt; threshold) {</span>
<span class="source-line-no">348</span><span id="line-348">                        double variance = realInfo.getVariance();</span>
<span class="source-line-no">349</span><span id="line-349">                        double sample = (innerRNG.nextGaussian() * Math.sqrt(variance)) + inputValue;</span>
<span class="source-line-no">350</span><span id="line-350">                        Feature newFeature = new Feature(info.getName(),sample);</span>
<span class="source-line-no">351</span><span id="line-351">                        tabularFeatures.add(newFeature);</span>
<span class="source-line-no">352</span><span id="line-352">                    }</span>
<span class="source-line-no">353</span><span id="line-353">                } else {</span>
<span class="source-line-no">354</span><span id="line-354">                    throw new IllegalStateException("Unsupported info type, expected CategoricalInfo or RealInfo, found " + info.getClass().getName());</span>
<span class="source-line-no">355</span><span id="line-355">                }</span>
<span class="source-line-no">356</span><span id="line-356">            }</span>
<span class="source-line-no">357</span><span id="line-357">            // Sample the binarised categorical features</span>
<span class="source-line-no">358</span><span id="line-358">            for (Map.Entry&lt;String,double[]&gt; e : binarisedCDFs.entrySet()) {</span>
<span class="source-line-no">359</span><span id="line-359">                // Sample from the CDF</span>
<span class="source-line-no">360</span><span id="line-360">                int sample = Util.sampleFromCDF(e.getValue(),innerRNG);</span>
<span class="source-line-no">361</span><span id="line-361">                // If the sample isn't zero (which is defined to be the last value to make the indices work)</span>
<span class="source-line-no">362</span><span id="line-362">                if (sample != (e.getValue().length-1)) {</span>
<span class="source-line-no">363</span><span id="line-363">                    VariableInfo info = binarisedInfos.get(e.getKey()).get(sample);</span>
<span class="source-line-no">364</span><span id="line-364">                    Feature newFeature = new Feature(info.getName(),1);</span>
<span class="source-line-no">365</span><span id="line-365">                    tabularFeatures.add(newFeature);</span>
<span class="source-line-no">366</span><span id="line-366">                }</span>
<span class="source-line-no">367</span><span id="line-367">            }</span>
<span class="source-line-no">368</span><span id="line-368">            // Add the tabular features to the current example</span>
<span class="source-line-no">369</span><span id="line-369">            sampledExample.addAll(tabularFeatures);</span>
<span class="source-line-no">370</span><span id="line-370">            // Calculate tabular distance</span>
<span class="source-line-no">371</span><span id="line-371">            double tabularDistance = measureDistance(tabularDomain,numTrainingExamples,tabularVector, SparseVector.createSparseVector(sampledExample,tabularDomain,false));</span>
<span class="source-line-no">372</span><span id="line-372"></span>
<span class="source-line-no">373</span><span id="line-373">            // features are the full text features</span>
<span class="source-line-no">374</span><span id="line-374">            List&lt;Feature&gt; textFeatures = new ArrayList&lt;&gt;();</span>
<span class="source-line-no">375</span><span id="line-375">            // Perturbed features are the binarised tokens</span>
<span class="source-line-no">376</span><span id="line-376">            List&lt;Feature&gt; perturbedFeatures = new ArrayList&lt;&gt;();</span>
<span class="source-line-no">377</span><span id="line-377"></span>
<span class="source-line-no">378</span><span id="line-378">            // Sample the text features</span>
<span class="source-line-no">379</span><span id="line-379">            double textDistance = 0.0;</span>
<span class="source-line-no">380</span><span id="line-380">            long numTokens = 0;</span>
<span class="source-line-no">381</span><span id="line-381">            for (Map.Entry&lt;String, String&gt; e : text.entrySet()) {</span>
<span class="source-line-no">382</span><span id="line-382">                String curText = e.getValue();</span>
<span class="source-line-no">383</span><span id="line-383">                List&lt;Token&gt; tokens = textTokens.get(e.getKey());</span>
<span class="source-line-no">384</span><span id="line-384">                numTokens += tokens.size();</span>
<span class="source-line-no">385</span><span id="line-385"></span>
<span class="source-line-no">386</span><span id="line-386">                // Sample a new Example.</span>
<span class="source-line-no">387</span><span id="line-387">                int[] activeFeatures = new int[tokens.size()];</span>
<span class="source-line-no">388</span><span id="line-388">                char[] sampledText = curText.toCharArray();</span>
<span class="source-line-no">389</span><span id="line-389">                for (int j = 0; j &lt; activeFeatures.length; j++) {</span>
<span class="source-line-no">390</span><span id="line-390">                    activeFeatures[j] = innerRNG.nextInt(2);</span>
<span class="source-line-no">391</span><span id="line-391">                    if (activeFeatures[j] == 0) {</span>
<span class="source-line-no">392</span><span id="line-392">                        textDistance++;</span>
<span class="source-line-no">393</span><span id="line-393">                        Token curToken = tokens.get(j);</span>
<span class="source-line-no">394</span><span id="line-394">                        Arrays.fill(sampledText, curToken.start, curToken.end, '\0');</span>
<span class="source-line-no">395</span><span id="line-395">                    }</span>
<span class="source-line-no">396</span><span id="line-396">                }</span>
<span class="source-line-no">397</span><span id="line-397">                String sampledString = new String(sampledText);</span>
<span class="source-line-no">398</span><span id="line-398">                sampledString = sampledString.replace("\0", "");</span>
<span class="source-line-no">399</span><span id="line-399"></span>
<span class="source-line-no">400</span><span id="line-400">                textFeatures.addAll(textFields.get(e.getKey()).process(sampledString));</span>
<span class="source-line-no">401</span><span id="line-401"></span>
<span class="source-line-no">402</span><span id="line-402">                for (int j = 0; j &lt; activeFeatures.length; j++) {</span>
<span class="source-line-no">403</span><span id="line-403">                    perturbedFeatures.add(new Feature(nameFeature(e.getKey(), tokens.get(j).text, j), activeFeatures[j]));</span>
<span class="source-line-no">404</span><span id="line-404">                }</span>
<span class="source-line-no">405</span><span id="line-405">            }</span>
<span class="source-line-no">406</span><span id="line-406">            // Add the text features to the current example</span>
<span class="source-line-no">407</span><span id="line-407">            sampledExample.addAll(textFeatures);</span>
<span class="source-line-no">408</span><span id="line-408">            // Calculate text distance</span>
<span class="source-line-no">409</span><span id="line-409">            double totalTextDistance = textDistance / numTokens;</span>
<span class="source-line-no">410</span><span id="line-410"></span>
<span class="source-line-no">411</span><span id="line-411">            // Label it using the full model.</span>
<span class="source-line-no">412</span><span id="line-412">            Prediction&lt;Label&gt; samplePrediction = innerModel.predict(sampledExample);</span>
<span class="source-line-no">413</span><span id="line-413"></span>
<span class="source-line-no">414</span><span id="line-414">            double totalLength = tabularFeatures.size() + perturbedFeatures.size();</span>
<span class="source-line-no">415</span><span id="line-415">            // Combine the distances and transform into a weight</span>
<span class="source-line-no">416</span><span id="line-416">            // Currently this averages the two values based on their relative sizes.</span>
<span class="source-line-no">417</span><span id="line-417">            double weight = 1.0 - ((tabularFeatures.size()*(kernelDist(tabularDistance,kernelWidth) + perturbedFeatures.size()*totalTextDistance) / totalLength));</span>
<span class="source-line-no">418</span><span id="line-418"></span>
<span class="source-line-no">419</span><span id="line-419">            // Generate the new sample with the appropriate label and weight.</span>
<span class="source-line-no">420</span><span id="line-420">            ArrayExample&lt;Regressor&gt; labelledSample = new ArrayExample&lt;&gt;(transformOutput(samplePrediction), (float) weight);</span>
<span class="source-line-no">421</span><span id="line-421">            labelledSample.addAll(tabularFeatures);</span>
<span class="source-line-no">422</span><span id="line-422">            labelledSample.addAll(perturbedFeatures);</span>
<span class="source-line-no">423</span><span id="line-423">            output.add(labelledSample);</span>
<span class="source-line-no">424</span><span id="line-424">        }</span>
<span class="source-line-no">425</span><span id="line-425"></span>
<span class="source-line-no">426</span><span id="line-426">        return output;</span>
<span class="source-line-no">427</span><span id="line-427">    }</span>
<span class="source-line-no">428</span><span id="line-428">}</span>




























































</pre>
</div>
</main>
</body>
</html>
